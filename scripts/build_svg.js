const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const promise = require('promise');
const svg2ttf = require('svg2ttf');
const SVGIcons2SVGFontStream = require('svgicons2svgfont');
const ttf2eot = require('ttf2eot');
const ttf2woff = require('ttf2woff');

const ROOT = path.resolve(__dirname, '..');
const SVG_SRC = path.resolve(ROOT, 'vue_src', 'static', 'svg');

const FONT_NAME = 'calchart-icons';

function font(ext) {
    return path.resolve(
        ROOT, 'vue_src', 'static', 'fonts', `${FONT_NAME}.${ext}`
    );
}

// our SVG files
const UTF_START = 0xe000;
let GLYPHS = fs.readdirSync(SVG_SRC)
    .filter(f => path.extname(f) === '.svg')
    .map((f, i) => {
        return {
            name: path.basename(f, '.svg'),
            file: path.resolve(SVG_SRC, f),
            code: UTF_START + i,
        };
    });

function createSVGFontFile(resolve, reject) {
    let svgFont = font('svg');
    let fontStream = new SVGIcons2SVGFontStream({
        fontName: FONT_NAME,
        fontHeight: 1000,
        normalize: true,
    });

    fontStream
        .pipe(fs.createWriteStream(svgFont))
        .on('finish', () => resolve(svgFont))
        .on('error', reject);

    GLYPHS.forEach(glyph => {
        let stream = fs.createReadStream(glyph.file);
        stream.metadata = {
            unicode: [String.fromCharCode(glyph.code)],
            name: glyph.name,
        };
        fontStream.write(stream);
    });

    fontStream.end();
}

function convert(from, to, fn) {
    let data = fn(fs.readFileSync(from, 'utf8'), {});
    fs.writeFileSync(to, new Buffer(data.buffer));
}

function createFontFiles(svgFont) {
    let ttf = svg2ttf(fs.readFileSync(svgFont, 'utf8'), {});
    fs.writeFileSync(font('ttf'), new Buffer(ttf.buffer));

    let eot = ttf2eot(ttf.buffer, {});
    fs.writeFileSync(font('eot'), new Buffer(eot.buffer));

    let woff = ttf2woff(ttf.buffer, {});
    fs.writeFileSync(font('woff'), new Buffer(woff.buffer));
}

let cssFile = `/* This file is automatically generated */

@font-face {
    font-family: '${FONT_NAME}';
    src: url('../fonts/${FONT_NAME}.eot');
    src: url('../fonts/${FONT_NAME}.eot#iefix') format('embedded-opentype'),
         url('../fonts/${FONT_NAME}.woff') format('woff'),
         url('../fonts/${FONT_NAME}.ttf') format('truetype'),
         url('../fonts/${FONT_NAME}.svg#${FONT_NAME}') format('svg');
    font-weight: normal;
    font-style: normal;
}

[data-icon] {
    display: inline-block;
}

[data-icon]:before {
    font-family: '${FONT_NAME}' !important;
    font-style: normal !important;
    font-weight: normal !important;
    font-variant: normal !important;
    text-transform: none !important;
    line-height: 1;
    speak: none;
}
`;
function createCSSFile() {
    GLYPHS.forEach(glyph => {
        cssFile += `
[data-icon="${glyph.name}"]:before {
    content: '\\${glyph.code.toString(16)}';
}
`;
    });

    fs.writeFileSync(
        path.resolve(ROOT, 'vue_src', 'static', 'vendor', `${FONT_NAME}.css`),
        cssFile,
    );
}

new Promise(createSVGFontFile)
    .then(createFontFiles)
    .then(createCSSFile)
    .catch(e => {
        console.error(e);
        process.exit(1);
    });
